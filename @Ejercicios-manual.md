Implementar Quicksort en C++.
Implementar Mergesort en C++.
Comparar la eficiencia de Quicksort y Mergesort con arrays grandes.
Implementar Heapsort.
Implementar Counting Sort para enteros positivos.
Implementar Radix Sort para números enteros.
Implementar Bucket Sort para números decimales.
Ordenar un array con std::sort.
Implementar búsqueda binaria iterativa.
Implementar búsqueda binaria recursiva.
Buscar el primer elemento mayor o igual a k en un array ordenado.
Buscar el último elemento menor o igual a k en un array ordenado.
Implementar búsqueda lineal.
Contar cuántas veces aparece un número en un array ordenado.
Encontrar el mínimo en un array rotado.
Encontrar el máximo en un array rotado.
Encontrar el k-ésimo elemento más grande (con sort).
Encontrar el k-ésimo elemento más grande (con heap).
Encontrar el k-ésimo elemento más pequeño (con sort).
Encontrar el k-ésimo elemento más pequeño (con heap).
Implementar búsqueda ternaria.
Implementar búsqueda exponencial.
Implementar búsqueda por interpolación.
Implementar búsqueda de salto (Jump Search).
Implementar búsqueda de Fibonacci.
Comparar los algoritmos de búsqueda en tiempo y eficiencia.
Encontrar dos números en un array que sumen un valor k.
Encontrar tres números en un array que sumen un valor k.
Implementar búsqueda de subcadena con fuerza bruta.
Implementar búsqueda de subcadena con KMP (Knuth-Morris-Pratt).
Implementar búsqueda de subcadena con algoritmo Boyer-Moore.
Implementar búsqueda de patrón con algoritmo Rabin-Karp.
Ordenar una lista enlazada simple.
Ordenar una lista doblemente enlazada.
Implementar ordenamiento por inserción.
Implementar ordenamiento por selección.
Implementar ordenamiento burbuja mejorado.
Implementar Shell Sort.
Comparar tiempos de todos los algoritmos de ordenamiento.
Comparar tiempos de todos los algoritmos de búsqueda.
Resolver el problema de la mochila 0/1 con programación dinámica.
Resolver el problema de la mochila fraccionaria con algoritmo voraz.
Resolver el problema de la suma de subconjuntos (Subset Sum).
Resolver el problema de la cadena de multiplicación de matrices.
Resolver el problema de la subsecuencia común más larga (LCS).
Resolver el problema de la subsecuencia creciente más larga (LIS).
Resolver el problema de la edición de cadenas (Edit Distance).
Resolver el problema de la partición de conjuntos en dos sumas iguales.
Resolver el problema de la escalera (formas de subir n escalones).
Resolver el problema de los números de Fibonacci con programación dinámica.
Resolver el problema de triangulación de un polígono.
Resolver el problema del corte de varillas (Rod Cutting).
Resolver el problema del cambio de monedas.
Resolver el problema de la ruta mínima en una cuadrícula.
Resolver el problema de las torres de Hanoi con recursión y DP.
Resolver el problema de la secuencia de dígitos máximos.
Resolver el problema de la palindromic subsequence.
Resolver el problema de la mochila multiobjetos.
Resolver el problema de la mochila multidimensional.
Resolver el problema del viajero (Traveling Salesman Problem).
Implementar BFS en un grafo no ponderado.
Implementar DFS en un grafo no ponderado.
Detectar un ciclo en un grafo con DFS.
Detectar un ciclo en un grafo con Union-Find.
Encontrar el camino más corto en un grafo con BFS.
Encontrar el camino más corto en un grafo ponderado con Dijkstra.
Encontrar el camino más corto en un grafo con Bellman-Ford.
Implementar el algoritmo de Floyd-Warshall.
Implementar el algoritmo de Warshall para cierre transitivo.
Implementar el algoritmo de Kruskal para árboles de expansión mínima.
Implementar el algoritmo de Prim para árboles de expansión mínima.
Implementar el algoritmo de Topological Sort.
Detectar componentes fuertemente conexas en un grafo (Kosaraju).
Detectar componentes fuertemente conexas en un grafo (Tarjan).
Implementar el algoritmo de puente en un grafo.
Implementar el algoritmo de puntos de articulación en un grafo.
Encontrar la ruta euleriana en un grafo.
Encontrar la ruta hamiltoniana en un grafo.
Implementar el algoritmo de Johnson para grafos esparcidos.
Resolver el problema del caballo de ajedrez (Knight’s Tour).
Resolver el problema de las n-reinas.
Resolver el problema de coloreo de grafos.
Resolver el problema de flujo máximo (Ford-Fulkerson).
Resolver el problema de flujo máximo (Edmonds-Karp).
Implementar el algoritmo de Dinic para flujo máximo.
Resolver el problema de emparejamiento bipartito (Kuhn).
Resolver el problema de emparejamiento bipartito (Hopcroft-Karp).
Implementar el algoritmo Hungarian para asignación.
Resolver el problema del camino más corto con restricciones.
Resolver el problema del árbol de Steiner.
Resolver el problema del árbol de expansión mínima en grafos dirigidos (Edmonds).
Implementar el algoritmo de Hierholzer para ciclos Eulerianos.
Resolver el problema de encontrar puentes en redes de comunicación.
Resolver el problema de encontrar clusters en un grafo.
Implementar el algoritmo PageRank simplificado.
Implementar el algoritmo de búsqueda A*.
Implementar el algoritmo IDA*.
Implementar el algoritmo bidireccional de búsqueda en grafos.
Resolver el problema de la ruta más barata con paradas obligatorias.
Resolver el problema de la ruta más corta con restricciones de capacidad.
Implementar búsqueda en grafos con heurística personalizada.
Resolver el problema de encontrar caminos disjuntos
Resolver el problema de planificación de tareas con grafos dirigidos.
Resolver el problema de flujo de circulación en grafos
Resolver el problema de asignación de frecuencias en redes.
Implementar un grafo con lista de adyacencia.
Implementar un grafo con matriz de adyacencia.
Implementar un grafo dirigido con lista de adyacencia.
Implementar un grafo dirigido con matriz de adyacencia.
Implementar una estructura de grafo con nodos genéricos.
Comparar representaciones de grafos en eficiencia.
Implementar un grafo no dirigido con lista de adyacencia.
Implementar un grafo no dirigido con matriz de adyacencia.
Implementar recorrido BFS con std::queue.
Implementar recorrido DFS con std::stack.
Implementar recorrido DFS recursivo.
Comparar tiempos entre BFS y DFS en grafos grandes.
Resolver el problema de los puentes en grafos no dirigidos.
Resolver el problema de las islas en una matriz binaria (DFS).
Resolver el problema de las islas en una matriz binaria (BFS).
Usar std::map para contar frecuencia de palabras.
Usar std::unordered_map para contar frecuencia de palabras.
Usar std::set para eliminar duplicados de una lista.
Usar std::unordered_set para eliminar duplicados de una lista.
Usar std::multiset para contar ocurrencias de elementos.
Usar std::pair para almacenar claves y valores.
Usar std::tuple para almacenar múltiples valores.
Usar std::vector para ordenar números.
Usar std::list para implementar una cola.
Usar std::deque para implementar una pila.
Usar std::priority_queue para obtener el máximo.
Usar std::priority_queue para obtener el mínimo.
Usar std::stack para invertir una cadena.
Usar std::queue para simular una cola de banco.
Usar std::forward_list para manejar datos secuenciales.
Usar std::array para operaciones básicas.
Usar std::bitset para operaciones binarias.
Usar std::map para ordenar claves automáticamente.
Usar std::unordered_map para acceso rápido a claves.
Usar std::vector con objetos y ordenar por un atributo.
Usar std::map para asociar nombres con edades.
Usar std::unordered_set para verificar duplicados.
Usar std::multimap para asociar múltiples valores a una clave.
Usar std::list para insertar y borrar en medio
Usar std::deque para insertar en ambos extremos.
Usar std::stack para evaluar expresiones postfijas.
Usar std::queue para recorrido BFS.
Usar std::priority_queue para resolver el problema del k-ésimo mayor.
Usar std::map para implementar un diccionario.
Usar std::unordered_map para implementar una tabla hash.
Implementar un árbol binario de búsqueda.
Implementar recorridos en árbol binario (preorden, inorden, postorden).
Implementar un árbol AVL.
Implementar un árbol Red-Black.
Implementar un trie para palabras.
Implementar un heap binario (máximo).
Implementar un heap binario (mínimo).
Implementar un heap d-ario.
Implementar un montículo de Fibonacci.
Implementar un árbol B.
Implementar un árbol B+.
Implementar un árbol Segment Tree.
Implementar un árbol Fenwick (Binary Indexed Tree).
Implementar un grafo con std::map y std::vector.
Implementar un grafo con std::unordered_map.
Usar std::map para grafo dirigido.
Usar std::unordered_map para grafo dirigido.
