Implementar Quicksort en C++.
Implementar Mergesort en C++.
Comparar la eficiencia de Quicksort y Mergesort con arrays grandes.
Implementar Heapsort.
Implementar Counting Sort para enteros positivos.
Implementar Radix Sort para números enteros.
Implementar Bucket Sort para números decimales.
Ordenar un array con std::sort.
Implementar búsqueda binaria iterativa.
Implementar búsqueda binaria recursiva.
Buscar el primer elemento mayor o igual a k en un array ordenado.
Buscar el último elemento menor o igual a k en un array ordenado.
Implementar búsqueda lineal.
Contar cuántas veces aparece un número en un array ordenado.
Encontrar el mínimo en un array rotado.
Encontrar el máximo en un array rotado.
Encontrar el k-ésimo elemento más grande (con sort).
Encontrar el k-ésimo elemento más grande (con heap).
Encontrar el k-ésimo elemento más pequeño (con sort).
Encontrar el k-ésimo elemento más pequeño (con heap).
Implementar búsqueda ternaria.
Implementar búsqueda exponencial.
Implementar búsqueda por interpolación.
Implementar búsqueda de salto (Jump Search).
Implementar búsqueda de Fibonacci.
Comparar los algoritmos de búsqueda en tiempo y eficiencia.
Encontrar dos números en un array que sumen un valor k.
Encontrar tres números en un array que sumen un valor k.
Implementar búsqueda de subcadena con fuerza bruta.
Implementar búsqueda de subcadena con KMP (Knuth-Morris-Pratt).
Implementar búsqueda de subcadena con algoritmo Boyer-Moore.
Implementar búsqueda de patrón con algoritmo Rabin-Karp.
Ordenar una lista enlazada simple.
Ordenar una lista doblemente enlazada.
Implementar ordenamiento por inserción.
Implementar ordenamiento por selección.
Implementar ordenamiento burbuja mejorado.
Implementar Shell Sort.
Comparar tiempos de todos los algoritmos de ordenamiento.
Comparar tiempos de todos los algoritmos de búsqueda.
Resolver el problema de la mochila 0/1 con programación dinámica.
Resolver el problema de la mochila fraccionaria con algoritmo voraz.
Resolver el problema de la suma de subconjuntos (Subset Sum).
Resolver el problema de la cadena de multiplicación de matrices.
Resolver el problema de la subsecuencia común más larga (LCS).
Resolver el problema de la subsecuencia creciente más larga (LIS).
Resolver el problema de la edición de cadenas (Edit Distance).
Resolver el problema de la partición de conjuntos en dos sumas iguales.
Resolver el problema de la escalera (formas de subir n escalones).
Resolver el problema de los números de Fibonacci con programación dinámica.
Resolver el problema de triangulación de un polígono.
Resolver el problema del corte de varillas (Rod Cutting).
Resolver el problema del cambio de monedas.
Resolver el problema de la ruta mínima en una cuadrícula.
Resolver el problema de las torres de Hanoi con recursión y DP.
Resolver el problema de la secuencia de dígitos máximos.
Resolver el problema de la palindromic subsequence.
Resolver el problema de la mochila multiobjetos.
Resolver el problema de la mochila multidimensional.
Resolver el problema del viajero (Traveling Salesman Problem).
Implementar BFS en un grafo no ponderado.
Implementar DFS en un grafo no ponderado.
Detectar un ciclo en un grafo con DFS.
Detectar un ciclo en un grafo con Union-Find.
Encontrar el camino más corto en un grafo con BFS.
Encontrar el camino más corto en un grafo ponderado con Dijkstra.
Encontrar el camino más corto en un grafo con Bellman-Ford.
Implementar el algoritmo de Floyd-Warshall.
Implementar el algoritmo de Warshall para cierre transitivo.
Implementar el algoritmo de Kruskal para árboles de expansión mínima.
Implementar el algoritmo de Prim para árboles de expansión mínima.
Implementar el algoritmo de Topological Sort.
Detectar componentes fuertemente conexas en un grafo (Kosaraju).
Detectar componentes fuertemente conexas en un grafo (Tarjan).
Implementar el algoritmo de puente en un grafo.
Implementar el algoritmo de puntos de articulación en un grafo.
Encontrar la ruta euleriana en un grafo.
Encontrar la ruta hamiltoniana en un grafo.
Implementar el algoritmo de Johnson para grafos esparcidos.
Resolver el problema del caballo de ajedrez (Knight’s Tour).
Resolver el problema de las n-reinas.
Resolver el problema de coloreo de grafos.
Resolver el problema de flujo máximo (Ford-Fulkerson).
Resolver el problema de flujo máximo (Edmonds-Karp).
Implementar el algoritmo de Dinic para flujo máximo.
Resolver el problema de emparejamiento bipartito (Kuhn).
Resolver el problema de emparejamiento bipartito (Hopcroft-Karp).
Implementar el algoritmo Hungarian para asignación.
Resolver el problema del camino más corto con restricciones.
Resolver el problema del árbol de Steiner.
Resolver el problema del árbol de expansión mínima en grafos dirigidos (Edmonds).
Implementar el algoritmo de Hierholzer para ciclos Eulerianos.
Resolver el problema de encontrar puentes en redes de comunicación.
Resolver el problema de encontrar clusters en un grafo.
Implementar el algoritmo PageRank simplificado.
Implementar el algoritmo de búsqueda A*.
Implementar el algoritmo IDA*.
Implementar el algoritmo bidireccional de búsqueda en grafos.
Resolver el problema de la ruta más barata con paradas obligatorias.
Resolver el problema de la ruta más corta con restricciones de capacidad.
